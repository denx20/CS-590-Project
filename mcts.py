# sus
# Tony will do this 

from function import FunctionTerm, Function

import numpy as np
import torch


# 'loc_term', 'power_term', 'interaction_term'

TERM_TYPES = 40
TREE_LEVELS = [
  [FunctionTerm('constant')],
  [
    FunctionTerm('loc_term'), 
    FunctionTerm('power_term', index_diff1=1), 
    FunctionTerm('power_term', index_diff1=2), 
    FunctionTerm('power_term', index_diff1=3)
  ],
  [
    FunctionTerm('loc_term', exponent1=2), 
    FunctionTerm('power_term', exponent1=2, index_diff1=1), 
    FunctionTerm('power_term', exponent1=2, index_diff1=2), 
    FunctionTerm('power_term', exponent1=2, index_diff1=3)
  ],
  [
    FunctionTerm('interaction_term', exponent1=1, exponent2=1, index_diff1=1,index_diff2=2), 
    FunctionTerm('interaction_term', exponent1=1, exponent2=1, index_diff1=1,index_diff2=3), 
    FunctionTerm('interaction_term', exponent1=1, exponent2=1, index_diff1=2,index_diff2=3)
  ],
  [
    FunctionTerm('loc_term', exponent1=2), 
    FunctionTerm('power_term', exponent1=2, index_diff1=1), 
    FunctionTerm('power_term', exponent1=2, index_diff1=2), 
    FunctionTerm('power_term', exponent1=2, index_diff1=3)
  ],
  [
    FunctionTerm('loc_term', exponent1=3), 
    FunctionTerm('power_term', exponent1=3, index_diff1=1), 
    FunctionTerm('power_term', exponent1=3, index_diff1=2), 
    FunctionTerm('power_term', exponent1=3, index_diff1=3)
  ],
  [
    FunctionTerm('interaction_term', exponent1=2, exponent2=1, index_diff1=1, index_diff2=2), 
    FunctionTerm('interaction_term', exponent1=2, exponent2=1, index_diff1=1, index_diff2=3), 
    FunctionTerm('interaction_term', exponent1=2, exponent2=1, index_diff1=2, index_diff2=3), 
    FunctionTerm('interaction_term', exponent1=1, exponent2=2, index_diff1=1, index_diff2=2), 
    FunctionTerm('interaction_term', exponent1=1, exponent2=2, index_diff1=1, index_diff2=3), 
    FunctionTerm('interaction_term', exponent1=1, exponent2=2, index_diff1=2, index_diff2=3)
  ]
]

# TODO
def get_power_set(l):
  return []

i = 0
term_id_map = {}
for level in TREE_LEVELS:
  for t in level:
    print(t.terms.keys())

# TODO: map FunctionTerm to numpy long array, as input to torch Embedding layer
def function_to_term_id(function):
  return np.array([1.0, 2.0])


# TODO: waiting for Jaden's implementation
def encode_sequence(seq):
  return seq


class MCTS_GRU(torch.nn.Module):
  def __init__(self, vocab_size, output_size, embed_size, hidden_size, num_layers, embedding_weights=None):
    super(MCTS_GRU, self).__init__()
    if embedding_weights:
      assert embed_size == embedding_weights.shape[-1]
      self.embedder = torch.nn.Embedding().from_pretrained(embedding_weights)
    else:
      self.embedder = torch.nn.Embedding(vocab_size, embed_size)
    self.gru = torch.nn.GRU(embed_size, hidden_size, num_layers, batch_first=True)
    self.head = torch.nn.Linear(hidden_size, output_size)
    self.softmax = torch.nn.Softmax(dim=-1)

  def forward(self, x):
    return self.softmax(self.head(self.gru(self.embedder(x))[1][-1]))



class MCTS:
  def __init__(self, target_sequence, rollouts=20, max_depth=len(TREE_LEVELS), is_training=True, neural_network_list=None, **nn_kwargs):
    self.target = target_sequence  # the sequence we are solving
    self.is_training = is_training   # whether we are training the network
    self.max_depth = max_depth    # max tree depth
    self.nn_list = neural_network_list    # self.nn_list[i] = NN for layer i of search tree
    
    if not self.nn_list:
      self.nn_list = [MCTS_GRU(vocab_size=TERM_TYPES, output_size=1+2**len(TREE_LEVELS[i]), **nn_kwargs)for i in range(max_depth)]
    
  # TODO
  def get_children(self, node):
    return get_power_set(TREE_LEVELS[node.depth]) + ['EOS']
    
  def get_children_probs(self, node):
    # get probability of selecting each children
    neural_network = self.nn_list[node.depth]
    probs = neural_network(torch.from_numpy(function_to_term_id(node.function))) # TODO: write this correctly
    probs = torch.exp(probs)/torch.exp(probs).sum() #softmax
    return probs

  def search(self, function):
    # TODO: tree search, randomly sample from probs generated by NN at each node
    self.state = None
    pass

  def select(self, function):
    pass

  def rollout(self, function):
    pass



class MCTSNode:
  def __init__(self, depth, function):
    self.depth = depth
    self.function = function
    print('MCTS Node sus')